import{i as T,O as L,P as U,Q as p,R as $,S as j,A as F,U as H,V as W,C as Q,W as z,r as E,X as w,Y as G,H as Z,Z as B,l as q,$ as X,B as P,y as Y,a0 as I}from"./CaSnHAEL.js";import{u as J}from"./LzioZZFg.js";const x={trailing:!0};function K(a,e=25,r={}){if(r={...x,...r},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let n,s,i=[],t,v;const o=(D,c)=>(t=A(a,D,c),t.finally(()=>{if(t=null,r.trailing&&v&&!s){const d=o(D,v);return v=null,d}}),t);return function(...D){return t?(r.trailing&&(v=D),t):new Promise(c=>{const d=!s&&r.leading;clearTimeout(s),s=setTimeout(()=>{s=null;const h=r.leading?n:o(this,D);for(const f of i)f(h);i=[]},e),d?(n=o(this,D),c(n)):i.push(c)})}}async function A(a,e,r){return await a.apply(e,r)}const k=a=>a==="defer"||a===!1;function aa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;ea(a[0],a[1])&&a.unshift(e);let[r,n,s={}]=a;const i=T(()=>L(r));if(typeof i.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof n!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=U();s.server??=!0,s.default??=sa,s.getCachedData??=N,s.lazy??=!1,s.immediate??=!0,s.deep??=p.deep,s.dedupe??="cancel",s._functionName,t._asyncData[i.value];const v={cause:"initial",dedupe:s.dedupe};t._asyncData[i.value]?._init||(v.cachedData=s.getCachedData(i.value,t,{cause:"initial"}),t._asyncData[i.value]=O(t,i.value,n,s,v.cachedData));const o=t._asyncData[i.value];o._deps++;const D=()=>t._asyncData[i.value].execute(v),c=s.server!==!1&&t.payload.serverRendered;{let f=function(l){const _=t._asyncData[l];_?._deps&&(_._deps--,_._deps===0&&_?._off())};const u=$();if(u&&c&&s.immediate&&!u.sp&&(u.sp=[]),u&&!u._nuxtOnBeforeMountCbs){u._nuxtOnBeforeMountCbs=[];const l=u._nuxtOnBeforeMountCbs;j(()=>{l.forEach(_=>{_()}),l.splice(0,l.length)}),F(()=>l.splice(0,l.length))}const y=u&&(u._nuxtClientOnly||H(W,!1));c&&t.isHydrating&&(o.error.value||o.data.value!=null)?(o.pending.value=!1,o.status.value=o.error.value?"error":"success"):u&&(!y&&t.payload.serverRendered&&t.isHydrating||s.lazy)&&s.immediate?u._nuxtOnBeforeMountCbs.push(D):s.immediate&&D();const m=X(),g=Q([i,...s.watch||[]],([l],[_])=>{if((l||_)&&l!==_){const R=t._asyncData[_]?.data.value!==p.value,V=t._asyncDataPromises[_]!==void 0;_&&f(_);const S={cause:"initial",dedupe:s.dedupe};if(!t._asyncData[l]?._init){let b;_&&R?b=t._asyncData[_]?.data.value:(b=s.getCachedData(l,t,{cause:"initial"}),S.cachedData=b),t._asyncData[l]=O(t,l,n,s,b)}t._asyncData[l]._deps++,(s.immediate||R||V)&&t._asyncData[l].execute(S)}else o._execute({cause:"watch",dedupe:s.dedupe})},{flush:"sync"});m&&z(()=>{g(),f(i.value)})}const d={data:C(()=>t._asyncData[i.value]?.data),pending:C(()=>t._asyncData[i.value]?.pending),status:C(()=>t._asyncData[i.value]?.status),error:C(()=>t._asyncData[i.value]?.error),refresh:(...f)=>t._asyncData[i.value].execute(...f),execute:(...f)=>t._asyncData[i.value].execute(...f),clear:()=>M(t,i.value)},h=Promise.resolve(t._asyncDataPromises[i.value]).then(()=>d);return Object.assign(h,d),h}function C(a){return T({get(){return a()?.value},set(e){const r=a();r&&(r.value=e)}})}function ea(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function M(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=p.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=p.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}function ta(a,e){const r={};for(const n of e)r[n]=a[n];return r}function O(a,e,r,n,s){a.payload._errors[e]??=p.errorValue;const i=n.getCachedData!==N,t=r,v=n.deep?E:w,o=s!=null,D=a.hook("app:data:refresh",async d=>{(!d||d.includes(e))&&await c.execute({cause:"refresh:hook"})}),c={data:v(o?s:n.default()),pending:w(!o),error:G(a.payload._errors,e),status:w("idle"),execute:(...d)=>{const[h,f=void 0]=d,u=h&&f===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]){if(k(u.dedupe??n.dedupe))return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}if(u.cause==="initial"||a.isHydrating){const m="cachedData"in u?u.cachedData:n.getCachedData(e,a,{cause:u.cause??"refresh:manual"});if(m!=null)return a.payload.data[e]=c.data.value=m,c.error.value=p.errorValue,c.status.value="success",Promise.resolve(m)}c.pending.value=!0,c.status.value="pending";const y=new Promise((m,g)=>{try{m(t(a))}catch(l){g(l)}}).then(async m=>{if(y.cancelled)return a._asyncDataPromises[e];let g=m;n.transform&&(g=await n.transform(m)),n.pick&&(g=ta(g,n.pick)),a.payload.data[e]=g,c.data.value=g,c.error.value=p.errorValue,c.status.value="success"}).catch(m=>{if(y.cancelled)return a._asyncDataPromises[e];c.error.value=B(m),c.data.value=q(n.default()),c.status.value="error"}).finally(()=>{y.cancelled||(c.pending.value=!1,delete a._asyncDataPromises[e])});return a._asyncDataPromises[e]=y,a._asyncDataPromises[e]},_execute:K((...d)=>c.execute(...d),0,{leading:!0}),_default:n.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{D(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),i||Z(()=>{a._asyncData[e]?._init||(M(a,e),c.execute=()=>Promise.resolve(),c.data.value=p.value)})}};return c}const sa=()=>p.value,N=(a,e,r)=>{if(e.isHydrating)return e.payload.data[a];if(r.cause!=="refresh:manual"&&r.cause!=="refresh:hook")return e.static.data[a]};function ia(a="",e=""){const r=new Date(a).getTime(),n=new Date(e).getTime(),s=new Date().getTime();return!r&&!n||s>=r&&s<=n||s>=r&&!n||!r&&s<=n}async function ca(a="",e=0){if(typeof a!="string"&&e===0)throw B({statusCode:503,statusMessage:"Modal name must be a string"});const r=e>0?"id":"modalName",n=P("modal"),s=I(),i=Y({strapi:{url:"/strv4/modales",params:{[`filters[${r}][$eqi]`]:e>0?e:a,locale:P("locale").value,publicationState:"live"}},bucket:{url:"/api/bucket",params:{locale:`${P("locale").value}/modals`,name:a}}}),t=E(null),v=E(null),o=async(f="")=>{const{data:u,status:y,error:m}=await aa("modal",async()=>await $fetch(i[f].url,{params:i[f].params}).then(l=>l.data));y.value==="success"?(t.value=u.value[0]||{},v.value=y.value):y.value==="error"&&(v.value=y.value)};await o(s?.public?.AWS_ENABLE_CLOUDFRONT_REQUEST==="true"||s?.public?.AWS_ENABLE_S3CLIENT_REQUEST==="true"?"bucket":"strapi"),v.value==="error"&&await o("strapi");const{__component:D,id:c,...d}={...J(t.value.dynZone)},h={type:D?`Modal${D.split(".").pop().split("-").map(f=>`${f.charAt(0).toLowerCase().toUpperCase()}${f.toLowerCase().slice(1)}`).join("")}`:null,data:Object.keys(d)?.length==0?null:d};n.value=h}export{ca as o,ia as s};
